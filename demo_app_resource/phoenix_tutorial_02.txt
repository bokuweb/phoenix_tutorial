#はじめに
一応、Rails Tutorialにある項目名に乗っ取って記述します。
(多少異なると思いますが・・・)

第二章では、デモアプリの作成を行う。
ユーザと短いマイクロポストのみをサポートするマイクロブログの作成。
但し、コードの自動生成を用いるため詳細については、以降の章にて細かく書いてある。

#データモデルの定義
まず、データモデルを最初に作成するのが普通。
ここで作成するのは以下の二つ。

- ユーザのモデル(users)
id(integer)、name(string)、email(string)

- マイクロポストのモデル(microposts)
id(integer)、content(string)、user_id(integer)

#Usersリソース
データモデルを表示するためのWebインターフェースに従って実装する。
データモデル+Webインターフェースで、Usersリソースとなる。

##コードの自動生成(Users)
Usersリソースを作成する。
PhoenixではEctoと言う機能を利用してコードを自動生成する。

Rubyにおけるscaffold的なものは、PhoenixのEctoで実現できる。
http://qiita.com/surume/items/cb7bba05e9e81db67da3

参考までにRailsとのコマンドを比較してみる。
Railsのコマンド： rails generate scaffold User name:string email:string
Phoenixのコマンド： mix phoenix.gen.html User users name:string email:string

似てますね(笑)
また、idパラメータはRailsと同じく、
自動的に主キーとしてデータベースに追加されるため、追加不要です。

----
>mix phoenix.gen.html User users name:string email:string
* creating priv/repo/migrations/20150620043753_create_user.exs
* creating web/models/user.ex
* creating test/models/user_test.exs
* creating web/controllers/user_controller.ex
* creating web/templates/user/edit.html.eex
* creating web/templates/user/form.html.eex
* creating web/templates/user/index.html.eex
* creating web/templates/user/new.html.eex
* creating web/templates/user/show.html.eex
* creating web/views/user_view.ex
* creating test/controllers/user_controller_test.exs

Add the resource to the proper scope in web/router.ex:

    resources "/users", UserController

and then update your repository by running migrations:

    $ mix ecto.migrate
----

生成後、以下の二つの手順を行う。

##ルーティングの追加
web/router.exを開き、ルートに以下の記述を追加する。
----
scope "/", DemoApp do
  pipe_through :browser # Use the default browser stack

  get "/", PageController, :index
  resources "/users", UserController # 追加行
end
----

Tips：
----
以下のコマンドでルーティングの確認ができる。
>mix phoenix.routes
page_path  GET     /                DemoApp.PageController.index/2
user_path  GET     /users           DemoApp.UserController.index/2
user_path  GET     /users/:id/edit  DemoApp.UserController.edit/2
user_path  GET     /users/new       DemoApp.UserController.new/2
user_path  GET     /users/:id       DemoApp.UserController.show/2
user_path  POST    /users           DemoApp.UserController.create/2
user_path  PATCH   /users/:id       DemoApp.UserController.update/2
           PUT     /users/:id       DemoApp.UserController.update/2
user_path  DELETE  /users/:id       DemoApp.UserController.delete/2
----

##ecto.migrate
userテーブルを作成するためにmigrateする。
Rails TutorialだとRakeを使ってmigrateしてます。
Phoenixでは、Ectoを使って実行する。

>mix ecto.migrate

わぁお！何だこれは？Phoenixのガイドにも出てないエラーが発生してるぞ！
----
** (exit) exited in: GenServer.call(#PID<0.168.0>, {:query, "SELECT count(1) FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n WHERE c.relkind IN ('r','v','m')\n
     AND c.relname = 'schema_migrations'\n       AND n.nspname = ANY (current_schemas(false))\n", []}, :infinity)
    ** (EXIT) %Postgrex.Error{message: nil, postgres: %{code: :invalid_catalog_name, file: "src\\backend\\utils\\init\\postinit.c", line: "794", message: <<131, 102, 129, 91, 131,
94, 131, 120, 129, 91, 131, 88, 34, 100, 101, 109, 111, 95, 97, 112, 112, 95, 100, 101, 118, 34, 130, 205, 145, 182, 141, 221, 130, 181, 130, 220, 130, 185, 130, 241>>, pg_code: "3
D000", routine: "InitPostgres", severity: "FATAL"}}
    (elixir) lib/gen_server.ex:356: GenServer.call/3
    (postgrex) lib/postgrex/connection.ex:87: Postgrex.Connection.query/4
    (ecto) lib/ecto/adapters/postgres/connection.ex:37: Ecto.Adapters.Postgres.Connection.query/4
    (stdlib) timer.erl:194: :timer.tc/3
    (ecto) lib/ecto/adapters/sql.ex:191: anonymous fn/6 in Ecto.Adapters.SQL.pool_query!/5
    (ecto) lib/ecto/adapters/sql.ex:615: Ecto.Adapters.SQL.pool_transaction/4
    (ecto) lib/ecto/adapters/sql.ex:189: Ecto.Adapters.SQL.pool_query!/5
    (ecto) lib/ecto/adapters/postgres.ex:59: Ecto.Adapters.Postgres.ddl_exists?/3
----

さて、上記のようなエラーが出た方は以下のコマンドを実行しよう！
(デフォルトのデータベースを作成していなかったのがエラーの原因)
>mix ecto.create
The database for DemoApp.Repo has been created.

再度、migrateを実行する。
>mix ecto.migrate
[info] == Running DemoApp.Repo.Migrations.CreateUser.change/0 forward
[info] create table users
[info] == Migrated in 0.2s

これで問題はない。

Tips：
----
Ectoの詳細を知りたい方は以下を参考にすると良いかと。
参考： http://www.phoenixframework.org/v0.13.1/docs/ecto-models
参考： https://github.com/elixir-lang/ecto
----

ここまで、できたら一度実行して確認してみましょう！

>mix phoenix.server
or
>iex -S mix phoenix.server

アドレス： http://localhost:4000/users

以下のような実行画面が表示できる。
画像

#ユーザページを表示する
私の方では各ページの機能を記述するだけに留めます。
(それぞれの実行ページが見たい場合、各人で実施して下さい)

- index
例) http://localhost:4000/users
ユーザ一覧を表示するページ。

- new
例) http://localhost:4000/users/new
新規のユーザ登録を行うページ。

- show
例) http://localhost:4000/users/1
ユーザ個別のプロファイルを表示するページ。
(URL中の数値1はid属性)

- edit
例) http://localhost:4000/users/1/edit
ユーザ情報の変更を行うページ。

- delete
例) http://localhost:4000/users/1
ユーザを削除する機能。

##MVCの挙動
MVCを説明するのは何番煎じか分からない位今更なので、Rails Tutorialを参照して下さい。
参考： http://railstutorial.jp/chapters/a-demo-app?version=4.0#sec-mvc_in_action

##Usersリソースの欠点
- データの検証が行われていない(Validationしてない)
- ユーザ認証が行われていない(誰でも操作できてしまう)
- テストを実施してない(コードで自動生成はしているが・・・)
- レイアウトが整えられていない(デザインと操作法が一貫してない)
- 理解が困難(自動生成したコード読めます？)

#Micropostsリソース
次はMicropostsリソースで同じことをやっていく。

##マイクロポストのページを表示する
Usersリソースを作成した時と同様な手順を踏みます。

----
>mix phoenix.gen.html Micropost microposts content:string user_id:integer
* creating priv/repo/migrations/20150620055222_create_micropost.exs
* creating web/models/micropost.ex
* creating test/models/micropost_test.exs
* creating web/controllers/micropost_controller.ex
* creating web/templates/micropost/edit.html.eex
* creating web/templates/micropost/form.html.eex
* creating web/templates/micropost/index.html.eex
* creating web/templates/micropost/new.html.eex
* creating web/templates/micropost/show.html.eex
* creating web/views/micropost_view.ex
* creating test/controllers/micropost_controller_test.exs

Add the resource to the proper scope in web/router.ex:

    resources "/microposts", MicropostController

and then update your repository by running migrations:

    $ mix ecto.migrate
----

web/router.exにルーティングを追加する。

----
>mix ecto.migrate
Compiled lib/demo_app.ex
Compiled web/models/micropost.ex
Compiled web/router.ex
Compiled web/views/page_view.ex
Compiled lib/demo_app/endpoint.ex
Compiled web/views/layout_view.ex
Compiled web/views/error_view.ex
Compiled web/views/micropost_view.ex
Compiled web/views/user_view.ex
Compiled web/controllers/user_controller.ex
Compiled web/controllers/page_controller.ex
Compiled web/controllers/micropost_controller.ex
Generated demo_app app
[info] == Running DemoApp.Repo.Migrations.CreateMicropost.change/0 forward
[info] create table microposts
[info] == Migrated in 0.1s
----

今度は、migrateでエラーは出ませんでしたね。

ルーティングを確認する。
----
>mix phoenix.routes
(pageとusersの結果も出る)
micropost_path  GET     /microposts           DemoApp.MicropostController.index/2
micropost_path  GET     /microposts/:id/edit  DemoApp.MicropostController.edit/2
micropost_path  GET     /microposts/new       DemoApp.MicropostController.new/2
micropost_path  GET     /microposts/:id       DemoApp.MicropostController.show/2
micropost_path  POST    /microposts           DemoApp.MicropostController.create/2
micropost_path  PATCH   /microposts/:id       DemoApp.MicropostController.update/2
                PUT     /microposts/:id       DemoApp.MicropostController.update/2
micropost_path  DELETE  /microposts/:id       DemoApp.MicropostController.delete/2
----

先ほど作成した"UsersController"が"MicropostsController"に置き換わっているだけで同一構造。
RESTアーキテクチャが反映されている。

Tips：
----
RESTについて知りたい方はこのスライドが分かりやすかったです。
参考： http://www.slideshare.net/unsolublesugar/res-tful
----

実行してマイクロポストのページを確認してみましょう。
>iex -S mix phoenix.server
アドレス： http://localhost:4000/microposts

##マイクロポストをマイクロにする
contentのパラメータに文字数制限を与えます。
Ecto.Changesetモジュールにある、検証(Validation)用の"validate_length/3"を利用します。

web/models/micropost.exを開き、
changeset関数を以下のように編集して下さい。
----
def changeset(model, params \\ :empty) do
  model
  |> cast(params, @required_fields, @optional_fields)
  |> validate_length(:content, min: 140) # 追加行
end
----

利用するモジュールについて詳しく知りたい方は、以下を参考にして下さい。
参考： http://hexdocs.pm/ecto/Ecto.Changeset.html#validate_length/3

##ユーザーとマイクロポストをhas_manyで関連づける
異なるデータモデル同士を関連付けるために、
PhoenixではEctoの機能(Schema.has_many/3)を利用します。

web/models/user.exを開き、schemaを以下のように編集する。
----
schema "users" do
  field :name, :string
  field :email, :string
  has_many :microposts, DemoApp.Micropost

  timestamps
end
----

web/models/micropost.exを開き、schemaを以下のように編集する。
----
schema "microposts" do
  field :content, :string
  belongs_to :user, DemoApp.User, foreign_key: :user_id

  timestamps
end
----

実際にUsersリソースとMicropostsリソースを同時に表示するのは、後の章で行います。
ここでは、これでデータモデルの関連付けができる程度の認識で結構です。

もし、どうしても実際に動かしたい！もっと詳しい説明が欲しい！っと言う方は、
PhoenixのGuideを参照してみて下さい。詳しい説明があります。
参考： http://www.phoenixframework.org/v0.13.1/docs/ecto-models

##継承の階層

OOP(オブジェクト指向プログラミング)の話になります。
関数型言語だから関係ないや・・・って思った方いますよね。
私もそう思いました。

詳しくはやりませんが、継承的な機能はElixirにも存在します。
参考： http://qiita.com/keithseahus/items/3c6b997eaad70a8b9426
参考： http://qiita.com/keithseahus/items/fc8d1dd6ede96855ca1a

まじかよ！まじだよ！！
分からない方は飛ばして問題ないかと思います。
追々、覚えていけば現状では問題は出ませんし。

ちなみに、私はC++でOOPをしていた時から継承の概念があまり好きではありません。(個人的志向)
それをするなら大概はhas-aの関係で実現させますので・・・いや、便利なんですけどね継承。

##デモアプリケーションのデプロイ
強いてやることを上げるならGitへコミットすることくらいかと。
なるべく、細かくコミットするのが良いですね。
(herokuを無料の範囲で借りようか検討中・・・)

#まとめ
まだまだ、理解できない部分は多いですが、
とりあえずの基本的な骨組部分はできたのではないでしょうか？

アプリケーションのプロジェクトごとGithubにアップします。
なので、今回はソースコード単体をアップはしません。

コミットからはずしてあるディレクトリとファイルは、
".gitignore"を見て下さい。それで足りないものが分かるかと思います。

リポジトリ： https://github.com/darui00kara/phoenix_tutorial